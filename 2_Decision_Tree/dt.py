import sysimport numpy as npimport pandas as pdclass DecisionTree:    class Node:        def __init__(self, attr, value, sample):            self.attr = attr            self.value = value            self.label = None            self.sample = pd.DataFrame(sample)            self.child = []    def __init__(self, path):        self.data = self.load_data(path)        self.root = self.model_construction("root", None, self.data)    @staticmethod    def load_data(path):        data = []        input_ = open(path, 'r')        attrs = input_.readline().split()        while True:            data_ = input_.readline()            if not data_:                break            data_ = data_.split()            data.append(data_)        input_.close()        return pd.DataFrame(data, columns=attrs)    def model_construction(self, attr, value, sample):        if sample.shape[0] == 0:            return None        elif sample[sample.columns[-1]].unique().shape[0] == 1:            node = self.Node(attr, value, sample)            node.label = sample[sample.columns[-1]].unique()[0]            return node        elif sample.columns.shape[0] == 1:            count = sample.groupby(sample.columns[-1]).count()            label = count.idxmax()            node = self.Node(attr, value, sample)            node.label = label            return node        else:            selected = Measures.info_gain(sample)            subset = sample.groupby(selected)            values = sample[selected].unique()            node = self.Node(attr, value, sample)            li = []            for value_ in values:                partition = subset.get_group(value_)                partition = partition.drop([selected], axis=1)                child = self.model_construction(selected, value_, partition)                if child is not None:                    li.append(child)            node.child = li            return node    def prediction(self, path):        data = []        input_ = open(path, 'r')        attrs = input_.readline().split()        while True:            data_ = input_.readline()            if not data_:                break            data_ = data_.split()            data.append(data_)        input_.close()        data = pd.DataFrame(data, columns=attrs)        data[self.data.columns[-1]] = None        for sample in data.itertuples():            cur = self.root            while cur.label is None:                attr = cur.child[0].attr                for child in cur.child:                    if child.value == sample[self.data.columns.get_loc(attr) + 1]:                        cur = child                        break                if child.value != sample[self.data.columns.get_loc(attr) + 1]:                    parent = cur.sample[cur.sample.columns[-1]].value_counts()                    cur.label = parent.idxmax()                    break            data.at[sample[0], self.data.columns[-1]] = cur.label        return data    def write(self, result, path):        input_ = open(path, 'w')        line_ = ""        for i in self.data.columns:            line_ += str(i) + "\t"        input_.write(line_ + "\n")        for line in result.itertuples():            line_ = ""            for i in line[1:]:                line_ += str(i)                if i is not line[-1]:                    line_ += "\t"            input_.write(line_ + "\n")        input_.close()class Measures:    @staticmethod    def info_gain(data):        attrs = data.columns        min_gain = 1        min_attr = attrs[0]        # pick one attribute and partition data based on attr types        for attr in attrs[:-1]:            subset = data.groupby(attr)            values = data[attr].unique()            info = 0            # compute Info(D_a)            for value in values:                partition = subset.get_group(value)                li = partition[attrs[-1]].value_counts()                li = li / partition.shape[0]                info += -np.sum(li * np.log2(li)) * partition.shape[0] / data.shape[0]            # search minimum info_gain            if min_gain >= info:                min_gain = info                min_attr = attr        return min_attr    @staticmethod    def gain_ratio(data):        attrs = data.columns        max_ratio = -1        max_attr = attrs[0]        before = data[attrs[-1]].value_counts() / data.shape[0]        before = -np.sum(before * np.log2(before))        # pick one attribute and partition data based on attr types        for attr in attrs[:-1]:            subset = data.groupby(attr)            values = data[attr].unique()            ratio = 0            split_info = 0            # compute Info(D_a)            for value in values:                partition = subset.get_group(value)                p = partition.shape[0] / data.shape[0]                split_info += -p * np.log2(p)                li = partition[attrs[-1]].value_counts()                li = li / partition.shape[0]                ratio += -np.sum(li * np.log2(li)) * p            ratio = (before - ratio) / split_info            # search minimum info_gain            if max_ratio <= ratio:                max_ratio = ratio                max_attr = attr        return max_attrif __name__ == "__main__":    path_train = sys.argv[1]    path_test = sys.argv[2]    path_output = sys.argv[3]    tree = DecisionTree("data/" + path_train)    res = tree.prediction("data/" + path_test)    tree.write(res, path_output)